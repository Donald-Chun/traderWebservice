/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef MT4WebService_TYPES_H
#define MT4WebService_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>




struct MT4GROUP_OPT {
  enum type {
    G_DELETE = 0,
    G_ENABLE = 1,
    G_DISABLE = 2,
    G_LEVERAGE = 3,
    G_SETGROUP = 4
  };
};

extern const std::map<int, const char*> _MT4GROUP_OPT_VALUES_TO_NAMES;

struct MT4DEAL_TYPE {
  enum type {
    D_IN = 0,
    D_OUT = 1
  };
};

extern const std::map<int, const char*> _MT4DEAL_TYPE_VALUES_TO_NAMES;

struct MT4TRADE_TYPE {
  enum type {
    T_BUY = 0,
    T_SELL = 1,
    T_BUY_LIMIT = 2,
    T_SELL_LIMIT = 3,
    T_BUY_STOP = 4,
    T_SELL_STOP = 5,
    T_BALANCE = 6,
    T_CREDIT = 7
  };
};

extern const std::map<int, const char*> _MT4TRADE_TYPE_VALUES_TO_NAMES;

struct MT4PASSWORD_TYPE {
  enum type {
    P_MASTER = 0,
    P_INVEST = 1
  };
};

extern const std::map<int, const char*> _MT4PASSWORD_TYPE_VALUES_TO_NAMES;

struct MT4PERIOD_TYPE {
  enum type {
    P_PERIOD_M1 = 0,
    P_PERIOD_M5 = 1,
    P_PERIOD_M15 = 2,
    P_PERIOD_M30 = 3,
    P_PERIOD_H1 = 4,
    P_PERIOD_H4 = 5,
    P_PERIOD_D1 = 6,
    P_PERIOD_W1 = 7,
    P_PERIOD_MN1 = 8
  };
};

extern const std::map<int, const char*> _MT4PERIOD_TYPE_VALUES_TO_NAMES;

struct MT4CHART_TYPE {
  enum type {
    C_CHART_RANGE_IN = 0,
    C_CHART_RANGE_OUT = 1,
    C_CHART_RANGE_LAST = 2
  };
};

extern const std::map<int, const char*> _MT4CHART_TYPE_VALUES_TO_NAMES;

class MT4UserRecord;

class MT4GroupCommand;

class MT4TradeRecord;

class MT4ConSession;

class MT4ConSessions;

class MT4ConSymbol;

class MT4ChartInfo;

class MT4RateInfo;

typedef struct _MT4UserRecord__isset {
  _MT4UserRecord__isset() : login(true), password_phone(false), enable(false), enable_change_password(false), enable_read_only(false), name(false), country(false), city(false), state(false), zipcode(false), address(false), phone(false), email(false), comment(false), id(false), status(false), agent_account(false), taxes(false), send_reports(false) {}
  bool login :1;
  bool password_phone :1;
  bool enable :1;
  bool enable_change_password :1;
  bool enable_read_only :1;
  bool name :1;
  bool country :1;
  bool city :1;
  bool state :1;
  bool zipcode :1;
  bool address :1;
  bool phone :1;
  bool email :1;
  bool comment :1;
  bool id :1;
  bool status :1;
  bool agent_account :1;
  bool taxes :1;
  bool send_reports :1;
} _MT4UserRecord__isset;

class MT4UserRecord {
 public:

  static const char* ascii_fingerprint; // = "12B8A6B40AE36ED55F8F7E3B0F396573";
  static const uint8_t binary_fingerprint[16]; // = {0x12,0xB8,0xA6,0xB4,0x0A,0xE3,0x6E,0xD5,0x5F,0x8F,0x7E,0x3B,0x0F,0x39,0x65,0x73};

  MT4UserRecord(const MT4UserRecord&);
  MT4UserRecord& operator=(const MT4UserRecord&);
  MT4UserRecord() : login(0), group(), password(), password_investor(), password_phone(), enable(0), enable_change_password(0), enable_read_only(0), name(), country(), city(), state(), zipcode(), address(), phone(), email(), comment(), id(), status(), leverage(0), agent_account(0), taxes(0), send_reports(0) {
  }

  virtual ~MT4UserRecord() throw();
  int32_t login;
  std::string group;
  std::string password;
  std::string password_investor;
  std::string password_phone;
  bool enable;
  bool enable_change_password;
  bool enable_read_only;
  std::string name;
  std::string country;
  std::string city;
  std::string state;
  std::string zipcode;
  std::string address;
  std::string phone;
  std::string email;
  std::string comment;
  std::string id;
  std::string status;
  int32_t leverage;
  int32_t agent_account;
  double taxes;
  bool send_reports;

  _MT4UserRecord__isset __isset;

  void __set_login(const int32_t val);

  void __set_group(const std::string& val);

  void __set_password(const std::string& val);

  void __set_password_investor(const std::string& val);

  void __set_password_phone(const std::string& val);

  void __set_enable(const bool val);

  void __set_enable_change_password(const bool val);

  void __set_enable_read_only(const bool val);

  void __set_name(const std::string& val);

  void __set_country(const std::string& val);

  void __set_city(const std::string& val);

  void __set_state(const std::string& val);

  void __set_zipcode(const std::string& val);

  void __set_address(const std::string& val);

  void __set_phone(const std::string& val);

  void __set_email(const std::string& val);

  void __set_comment(const std::string& val);

  void __set_id(const std::string& val);

  void __set_status(const std::string& val);

  void __set_leverage(const int32_t val);

  void __set_agent_account(const int32_t val);

  void __set_taxes(const double val);

  void __set_send_reports(const bool val);

  bool operator == (const MT4UserRecord & rhs) const
  {
    if (__isset.login != rhs.__isset.login)
      return false;
    else if (__isset.login && !(login == rhs.login))
      return false;
    if (!(group == rhs.group))
      return false;
    if (!(password == rhs.password))
      return false;
    if (!(password_investor == rhs.password_investor))
      return false;
    if (__isset.password_phone != rhs.__isset.password_phone)
      return false;
    else if (__isset.password_phone && !(password_phone == rhs.password_phone))
      return false;
    if (__isset.enable != rhs.__isset.enable)
      return false;
    else if (__isset.enable && !(enable == rhs.enable))
      return false;
    if (__isset.enable_change_password != rhs.__isset.enable_change_password)
      return false;
    else if (__isset.enable_change_password && !(enable_change_password == rhs.enable_change_password))
      return false;
    if (__isset.enable_read_only != rhs.__isset.enable_read_only)
      return false;
    else if (__isset.enable_read_only && !(enable_read_only == rhs.enable_read_only))
      return false;
    if (__isset.name != rhs.__isset.name)
      return false;
    else if (__isset.name && !(name == rhs.name))
      return false;
    if (__isset.country != rhs.__isset.country)
      return false;
    else if (__isset.country && !(country == rhs.country))
      return false;
    if (__isset.city != rhs.__isset.city)
      return false;
    else if (__isset.city && !(city == rhs.city))
      return false;
    if (__isset.state != rhs.__isset.state)
      return false;
    else if (__isset.state && !(state == rhs.state))
      return false;
    if (__isset.zipcode != rhs.__isset.zipcode)
      return false;
    else if (__isset.zipcode && !(zipcode == rhs.zipcode))
      return false;
    if (__isset.address != rhs.__isset.address)
      return false;
    else if (__isset.address && !(address == rhs.address))
      return false;
    if (__isset.phone != rhs.__isset.phone)
      return false;
    else if (__isset.phone && !(phone == rhs.phone))
      return false;
    if (__isset.email != rhs.__isset.email)
      return false;
    else if (__isset.email && !(email == rhs.email))
      return false;
    if (__isset.comment != rhs.__isset.comment)
      return false;
    else if (__isset.comment && !(comment == rhs.comment))
      return false;
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    if (!(leverage == rhs.leverage))
      return false;
    if (__isset.agent_account != rhs.__isset.agent_account)
      return false;
    else if (__isset.agent_account && !(agent_account == rhs.agent_account))
      return false;
    if (__isset.taxes != rhs.__isset.taxes)
      return false;
    else if (__isset.taxes && !(taxes == rhs.taxes))
      return false;
    if (__isset.send_reports != rhs.__isset.send_reports)
      return false;
    else if (__isset.send_reports && !(send_reports == rhs.send_reports))
      return false;
    return true;
  }
  bool operator != (const MT4UserRecord &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MT4UserRecord & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const MT4UserRecord& obj);
};

void swap(MT4UserRecord &a, MT4UserRecord &b);

typedef struct _MT4GroupCommand__isset {
  _MT4GroupCommand__isset() : newgroup(false), leverage(false) {}
  bool newgroup :1;
  bool leverage :1;
} _MT4GroupCommand__isset;

class MT4GroupCommand {
 public:

  static const char* ascii_fingerprint; // = "40230245CB158B7D1C023C52256CCE00";
  static const uint8_t binary_fingerprint[16]; // = {0x40,0x23,0x02,0x45,0xCB,0x15,0x8B,0x7D,0x1C,0x02,0x3C,0x52,0x25,0x6C,0xCE,0x00};

  MT4GroupCommand(const MT4GroupCommand&);
  MT4GroupCommand& operator=(const MT4GroupCommand&);
  MT4GroupCommand() : group_opt((MT4GROUP_OPT::type)0), newgroup(), leverage(0) {
  }

  virtual ~MT4GroupCommand() throw();
  std::vector<int32_t>  user_logins;
  MT4GROUP_OPT::type group_opt;
  std::string newgroup;
  int32_t leverage;

  _MT4GroupCommand__isset __isset;

  void __set_user_logins(const std::vector<int32_t> & val);

  void __set_group_opt(const MT4GROUP_OPT::type val);

  void __set_newgroup(const std::string& val);

  void __set_leverage(const int32_t val);

  bool operator == (const MT4GroupCommand & rhs) const
  {
    if (!(user_logins == rhs.user_logins))
      return false;
    if (!(group_opt == rhs.group_opt))
      return false;
    if (__isset.newgroup != rhs.__isset.newgroup)
      return false;
    else if (__isset.newgroup && !(newgroup == rhs.newgroup))
      return false;
    if (__isset.leverage != rhs.__isset.leverage)
      return false;
    else if (__isset.leverage && !(leverage == rhs.leverage))
      return false;
    return true;
  }
  bool operator != (const MT4GroupCommand &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MT4GroupCommand & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const MT4GroupCommand& obj);
};

void swap(MT4GroupCommand &a, MT4GroupCommand &b);

typedef struct _MT4TradeRecord__isset {
  _MT4TradeRecord__isset() : order(false), login(false), symbol(false), digits(false), cmd(false), open_time(false), open_price(false), sl(false), tp(false), close_time(false), value_date(false), expiration(false), commission(false), swap(false), close_price(false), profit(false), taxes(false), comment(false), timestamp(false), volume(false) {}
  bool order :1;
  bool login :1;
  bool symbol :1;
  bool digits :1;
  bool cmd :1;
  bool open_time :1;
  bool open_price :1;
  bool sl :1;
  bool tp :1;
  bool close_time :1;
  bool value_date :1;
  bool expiration :1;
  bool commission :1;
  bool swap :1;
  bool close_price :1;
  bool profit :1;
  bool taxes :1;
  bool comment :1;
  bool timestamp :1;
  bool volume :1;
} _MT4TradeRecord__isset;

class MT4TradeRecord {
 public:

  static const char* ascii_fingerprint; // = "19CB3081069AFB49FD5B5C9C9B0EFA73";
  static const uint8_t binary_fingerprint[16]; // = {0x19,0xCB,0x30,0x81,0x06,0x9A,0xFB,0x49,0xFD,0x5B,0x5C,0x9C,0x9B,0x0E,0xFA,0x73};

  MT4TradeRecord(const MT4TradeRecord&);
  MT4TradeRecord& operator=(const MT4TradeRecord&);
  MT4TradeRecord() : order(0), login(0), symbol(), digits(0), cmd((MT4TRADE_TYPE::type)0), open_time(0), open_price(0), sl(0), tp(0), close_time(0), value_date(0), expiration(0), commission(0), swap(0), close_price(0), profit(0), taxes(0), comment(), timestamp(0), volume(0) {
  }

  virtual ~MT4TradeRecord() throw();
  int32_t order;
  int32_t login;
  std::string symbol;
  int32_t digits;
  MT4TRADE_TYPE::type cmd;
  int64_t open_time;
  double open_price;
  double sl;
  double tp;
  int64_t close_time;
  int64_t value_date;
  int64_t expiration;
  double commission;
  double swap;
  double close_price;
  double profit;
  double taxes;
  std::string comment;
  int64_t timestamp;
  int32_t volume;

  _MT4TradeRecord__isset __isset;

  void __set_order(const int32_t val);

  void __set_login(const int32_t val);

  void __set_symbol(const std::string& val);

  void __set_digits(const int32_t val);

  void __set_cmd(const MT4TRADE_TYPE::type val);

  void __set_open_time(const int64_t val);

  void __set_open_price(const double val);

  void __set_sl(const double val);

  void __set_tp(const double val);

  void __set_close_time(const int64_t val);

  void __set_value_date(const int64_t val);

  void __set_expiration(const int64_t val);

  void __set_commission(const double val);

  void __set_swap(const double val);

  void __set_close_price(const double val);

  void __set_profit(const double val);

  void __set_taxes(const double val);

  void __set_comment(const std::string& val);

  void __set_timestamp(const int64_t val);

  void __set_volume(const int32_t val);

  bool operator == (const MT4TradeRecord & rhs) const
  {
    if (!(order == rhs.order))
      return false;
    if (!(login == rhs.login))
      return false;
    if (!(symbol == rhs.symbol))
      return false;
    if (!(digits == rhs.digits))
      return false;
    if (!(cmd == rhs.cmd))
      return false;
    if (!(open_time == rhs.open_time))
      return false;
    if (!(open_price == rhs.open_price))
      return false;
    if (!(sl == rhs.sl))
      return false;
    if (!(tp == rhs.tp))
      return false;
    if (!(close_time == rhs.close_time))
      return false;
    if (!(value_date == rhs.value_date))
      return false;
    if (!(expiration == rhs.expiration))
      return false;
    if (!(commission == rhs.commission))
      return false;
    if (!(swap == rhs.swap))
      return false;
    if (!(close_price == rhs.close_price))
      return false;
    if (!(profit == rhs.profit))
      return false;
    if (!(taxes == rhs.taxes))
      return false;
    if (!(comment == rhs.comment))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(volume == rhs.volume))
      return false;
    return true;
  }
  bool operator != (const MT4TradeRecord &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MT4TradeRecord & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const MT4TradeRecord& obj);
};

void swap(MT4TradeRecord &a, MT4TradeRecord &b);

typedef struct _MT4ConSession__isset {
  _MT4ConSession__isset() : open_hour(false), open_min(false), close_hour(false), close_min(false), open(false), close(false), align(false) {}
  bool open_hour :1;
  bool open_min :1;
  bool close_hour :1;
  bool close_min :1;
  bool open :1;
  bool close :1;
  bool align :1;
} _MT4ConSession__isset;

class MT4ConSession {
 public:

  static const char* ascii_fingerprint; // = "213C9641ACA2EBD5AF5397F20C2E6578";
  static const uint8_t binary_fingerprint[16]; // = {0x21,0x3C,0x96,0x41,0xAC,0xA2,0xEB,0xD5,0xAF,0x53,0x97,0xF2,0x0C,0x2E,0x65,0x78};

  MT4ConSession(const MT4ConSession&);
  MT4ConSession& operator=(const MT4ConSession&);
  MT4ConSession() : open_hour(0), open_min(0), close_hour(0), close_min(0), open(0), close(0) {
  }

  virtual ~MT4ConSession() throw();
  int16_t open_hour;
  int16_t open_min;
  int16_t close_hour;
  int16_t close_min;
  int32_t open;
  int32_t close;
  std::vector<int16_t>  align;

  _MT4ConSession__isset __isset;

  void __set_open_hour(const int16_t val);

  void __set_open_min(const int16_t val);

  void __set_close_hour(const int16_t val);

  void __set_close_min(const int16_t val);

  void __set_open(const int32_t val);

  void __set_close(const int32_t val);

  void __set_align(const std::vector<int16_t> & val);

  bool operator == (const MT4ConSession & rhs) const
  {
    if (!(open_hour == rhs.open_hour))
      return false;
    if (!(open_min == rhs.open_min))
      return false;
    if (!(close_hour == rhs.close_hour))
      return false;
    if (!(close_min == rhs.close_min))
      return false;
    if (!(open == rhs.open))
      return false;
    if (!(close == rhs.close))
      return false;
    if (!(align == rhs.align))
      return false;
    return true;
  }
  bool operator != (const MT4ConSession &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MT4ConSession & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const MT4ConSession& obj);
};

void swap(MT4ConSession &a, MT4ConSession &b);

typedef struct _MT4ConSessions__isset {
  _MT4ConSessions__isset() : quote(false), trade(false), quote_overnight(false), trade_overnight(false) {}
  bool quote :1;
  bool trade :1;
  bool quote_overnight :1;
  bool trade_overnight :1;
} _MT4ConSessions__isset;

class MT4ConSessions {
 public:

  static const char* ascii_fingerprint; // = "C2C0D57C694C00F4EBDC80F65D208E78";
  static const uint8_t binary_fingerprint[16]; // = {0xC2,0xC0,0xD5,0x7C,0x69,0x4C,0x00,0xF4,0xEB,0xDC,0x80,0xF6,0x5D,0x20,0x8E,0x78};

  MT4ConSessions(const MT4ConSessions&);
  MT4ConSessions& operator=(const MT4ConSessions&);
  MT4ConSessions() : quote_overnight(0), trade_overnight(0) {
  }

  virtual ~MT4ConSessions() throw();
  std::vector<MT4ConSession>  quote;
  std::vector<MT4ConSession>  trade;
  int32_t quote_overnight;
  int32_t trade_overnight;

  _MT4ConSessions__isset __isset;

  void __set_quote(const std::vector<MT4ConSession> & val);

  void __set_trade(const std::vector<MT4ConSession> & val);

  void __set_quote_overnight(const int32_t val);

  void __set_trade_overnight(const int32_t val);

  bool operator == (const MT4ConSessions & rhs) const
  {
    if (!(quote == rhs.quote))
      return false;
    if (!(trade == rhs.trade))
      return false;
    if (!(quote_overnight == rhs.quote_overnight))
      return false;
    if (!(trade_overnight == rhs.trade_overnight))
      return false;
    return true;
  }
  bool operator != (const MT4ConSessions &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MT4ConSessions & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const MT4ConSessions& obj);
};

void swap(MT4ConSessions &a, MT4ConSessions &b);

typedef struct _MT4ConSymbol__isset {
  _MT4ConSymbol__isset() : bid_tickvalue(false), ask_tickvalue(false), symbol(false), description(false), source(false), currency(false), type(false), digits(false), trade(false), count(false), count_original(false), realtime(false), starting(false), expiration(false), sessions(false), profit_mode(false), profit_reserved(false), filter(false), filter_counter(false), filter_limit(false), filter_smoothing(false), filter_reserved(false), logging(false), spread(false), spread_balance(false), exemode(false), swap_enable(false), swap_type(false), swap_long(false), swap_short(false), swap_rollover3days(false), contract_size(false), tick_value(false), tick_size(false), stops_level(false), gtc_pendings(false), margin_mode(false), margin_initial(false), margin_maintenance(false), margin_hedged(false), margin_divider(false), point(false), multiply(false), long_only(false), instant_max_volume(false), margin_currency(false), freeze_level(false), margin_hedged_strong(false), value_date(false), quotes_delay(false), swap_openprice(false) {}
  bool bid_tickvalue :1;
  bool ask_tickvalue :1;
  bool symbol :1;
  bool description :1;
  bool source :1;
  bool currency :1;
  bool type :1;
  bool digits :1;
  bool trade :1;
  bool count :1;
  bool count_original :1;
  bool realtime :1;
  bool starting :1;
  bool expiration :1;
  bool sessions :1;
  bool profit_mode :1;
  bool profit_reserved :1;
  bool filter :1;
  bool filter_counter :1;
  bool filter_limit :1;
  bool filter_smoothing :1;
  bool filter_reserved :1;
  bool logging :1;
  bool spread :1;
  bool spread_balance :1;
  bool exemode :1;
  bool swap_enable :1;
  bool swap_type :1;
  bool swap_long :1;
  bool swap_short :1;
  bool swap_rollover3days :1;
  bool contract_size :1;
  bool tick_value :1;
  bool tick_size :1;
  bool stops_level :1;
  bool gtc_pendings :1;
  bool margin_mode :1;
  bool margin_initial :1;
  bool margin_maintenance :1;
  bool margin_hedged :1;
  bool margin_divider :1;
  bool point :1;
  bool multiply :1;
  bool long_only :1;
  bool instant_max_volume :1;
  bool margin_currency :1;
  bool freeze_level :1;
  bool margin_hedged_strong :1;
  bool value_date :1;
  bool quotes_delay :1;
  bool swap_openprice :1;
} _MT4ConSymbol__isset;

class MT4ConSymbol {
 public:

  static const char* ascii_fingerprint; // = "FFA48ACB2D6DBB6DD767A1658360B8D2";
  static const uint8_t binary_fingerprint[16]; // = {0xFF,0xA4,0x8A,0xCB,0x2D,0x6D,0xBB,0x6D,0xD7,0x67,0xA1,0x65,0x83,0x60,0xB8,0xD2};

  MT4ConSymbol(const MT4ConSymbol&);
  MT4ConSymbol& operator=(const MT4ConSymbol&);
  MT4ConSymbol() : bid_tickvalue(0), ask_tickvalue(0), symbol(), description(), source(), currency(), type(0), digits(0), trade(0), count(0), count_original(0), realtime(0), starting(0), expiration(0), profit_mode(0), profit_reserved(0), filter(0), filter_counter(0), filter_limit(0), filter_smoothing(0), filter_reserved(0), logging(0), spread(0), spread_balance(0), exemode(0), swap_enable(0), swap_type(0), swap_long(0), swap_short(0), swap_rollover3days(0), contract_size(0), tick_value(0), tick_size(0), stops_level(0), gtc_pendings(0), margin_mode(0), margin_initial(0), margin_maintenance(0), margin_hedged(0), margin_divider(0), point(0), multiply(0), long_only(0), instant_max_volume(0), margin_currency(), freeze_level(0), margin_hedged_strong(0), value_date(0), quotes_delay(0), swap_openprice(0) {
  }

  virtual ~MT4ConSymbol() throw();
  double bid_tickvalue;
  double ask_tickvalue;
  std::string symbol;
  std::string description;
  std::string source;
  std::string currency;
  int32_t type;
  int32_t digits;
  int32_t trade;
  int32_t count;
  int32_t count_original;
  int32_t realtime;
  int64_t starting;
  int64_t expiration;
  std::vector<MT4ConSessions>  sessions;
  int32_t profit_mode;
  int32_t profit_reserved;
  int32_t filter;
  int32_t filter_counter;
  double filter_limit;
  int32_t filter_smoothing;
  double filter_reserved;
  int32_t logging;
  int32_t spread;
  int32_t spread_balance;
  int32_t exemode;
  int32_t swap_enable;
  int32_t swap_type;
  double swap_long;
  double swap_short;
  int32_t swap_rollover3days;
  double contract_size;
  double tick_value;
  double tick_size;
  int32_t stops_level;
  int32_t gtc_pendings;
  int32_t margin_mode;
  double margin_initial;
  double margin_maintenance;
  double margin_hedged;
  double margin_divider;
  double point;
  double multiply;
  int32_t long_only;
  int32_t instant_max_volume;
  std::string margin_currency;
  int32_t freeze_level;
  int32_t margin_hedged_strong;
  int64_t value_date;
  int32_t quotes_delay;
  int32_t swap_openprice;

  _MT4ConSymbol__isset __isset;

  void __set_bid_tickvalue(const double val);

  void __set_ask_tickvalue(const double val);

  void __set_symbol(const std::string& val);

  void __set_description(const std::string& val);

  void __set_source(const std::string& val);

  void __set_currency(const std::string& val);

  void __set_type(const int32_t val);

  void __set_digits(const int32_t val);

  void __set_trade(const int32_t val);

  void __set_count(const int32_t val);

  void __set_count_original(const int32_t val);

  void __set_realtime(const int32_t val);

  void __set_starting(const int64_t val);

  void __set_expiration(const int64_t val);

  void __set_sessions(const std::vector<MT4ConSessions> & val);

  void __set_profit_mode(const int32_t val);

  void __set_profit_reserved(const int32_t val);

  void __set_filter(const int32_t val);

  void __set_filter_counter(const int32_t val);

  void __set_filter_limit(const double val);

  void __set_filter_smoothing(const int32_t val);

  void __set_filter_reserved(const double val);

  void __set_logging(const int32_t val);

  void __set_spread(const int32_t val);

  void __set_spread_balance(const int32_t val);

  void __set_exemode(const int32_t val);

  void __set_swap_enable(const int32_t val);

  void __set_swap_type(const int32_t val);

  void __set_swap_long(const double val);

  void __set_swap_short(const double val);

  void __set_swap_rollover3days(const int32_t val);

  void __set_contract_size(const double val);

  void __set_tick_value(const double val);

  void __set_tick_size(const double val);

  void __set_stops_level(const int32_t val);

  void __set_gtc_pendings(const int32_t val);

  void __set_margin_mode(const int32_t val);

  void __set_margin_initial(const double val);

  void __set_margin_maintenance(const double val);

  void __set_margin_hedged(const double val);

  void __set_margin_divider(const double val);

  void __set_point(const double val);

  void __set_multiply(const double val);

  void __set_long_only(const int32_t val);

  void __set_instant_max_volume(const int32_t val);

  void __set_margin_currency(const std::string& val);

  void __set_freeze_level(const int32_t val);

  void __set_margin_hedged_strong(const int32_t val);

  void __set_value_date(const int64_t val);

  void __set_quotes_delay(const int32_t val);

  void __set_swap_openprice(const int32_t val);

  bool operator == (const MT4ConSymbol & rhs) const
  {
    if (!(bid_tickvalue == rhs.bid_tickvalue))
      return false;
    if (!(ask_tickvalue == rhs.ask_tickvalue))
      return false;
    if (!(symbol == rhs.symbol))
      return false;
    if (!(description == rhs.description))
      return false;
    if (!(source == rhs.source))
      return false;
    if (!(currency == rhs.currency))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(digits == rhs.digits))
      return false;
    if (!(trade == rhs.trade))
      return false;
    if (!(count == rhs.count))
      return false;
    if (!(count_original == rhs.count_original))
      return false;
    if (!(realtime == rhs.realtime))
      return false;
    if (!(starting == rhs.starting))
      return false;
    if (!(expiration == rhs.expiration))
      return false;
    if (!(sessions == rhs.sessions))
      return false;
    if (!(profit_mode == rhs.profit_mode))
      return false;
    if (!(profit_reserved == rhs.profit_reserved))
      return false;
    if (!(filter == rhs.filter))
      return false;
    if (!(filter_counter == rhs.filter_counter))
      return false;
    if (!(filter_limit == rhs.filter_limit))
      return false;
    if (!(filter_smoothing == rhs.filter_smoothing))
      return false;
    if (!(filter_reserved == rhs.filter_reserved))
      return false;
    if (!(logging == rhs.logging))
      return false;
    if (!(spread == rhs.spread))
      return false;
    if (!(spread_balance == rhs.spread_balance))
      return false;
    if (!(exemode == rhs.exemode))
      return false;
    if (!(swap_enable == rhs.swap_enable))
      return false;
    if (!(swap_type == rhs.swap_type))
      return false;
    if (!(swap_long == rhs.swap_long))
      return false;
    if (!(swap_short == rhs.swap_short))
      return false;
    if (!(swap_rollover3days == rhs.swap_rollover3days))
      return false;
    if (!(contract_size == rhs.contract_size))
      return false;
    if (!(tick_value == rhs.tick_value))
      return false;
    if (!(tick_size == rhs.tick_size))
      return false;
    if (!(stops_level == rhs.stops_level))
      return false;
    if (!(gtc_pendings == rhs.gtc_pendings))
      return false;
    if (!(margin_mode == rhs.margin_mode))
      return false;
    if (!(margin_initial == rhs.margin_initial))
      return false;
    if (!(margin_maintenance == rhs.margin_maintenance))
      return false;
    if (!(margin_hedged == rhs.margin_hedged))
      return false;
    if (!(margin_divider == rhs.margin_divider))
      return false;
    if (!(point == rhs.point))
      return false;
    if (!(multiply == rhs.multiply))
      return false;
    if (!(long_only == rhs.long_only))
      return false;
    if (!(instant_max_volume == rhs.instant_max_volume))
      return false;
    if (!(margin_currency == rhs.margin_currency))
      return false;
    if (!(freeze_level == rhs.freeze_level))
      return false;
    if (!(margin_hedged_strong == rhs.margin_hedged_strong))
      return false;
    if (!(value_date == rhs.value_date))
      return false;
    if (!(quotes_delay == rhs.quotes_delay))
      return false;
    if (!(swap_openprice == rhs.swap_openprice))
      return false;
    return true;
  }
  bool operator != (const MT4ConSymbol &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MT4ConSymbol & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const MT4ConSymbol& obj);
};

void swap(MT4ConSymbol &a, MT4ConSymbol &b);

typedef struct _MT4ChartInfo__isset {
  _MT4ChartInfo__isset() : symbol(false), period(false), start(false), _end(false), timesign(false), mode(false) {}
  bool symbol :1;
  bool period :1;
  bool start :1;
  bool _end :1;
  bool timesign :1;
  bool mode :1;
} _MT4ChartInfo__isset;

class MT4ChartInfo {
 public:

  static const char* ascii_fingerprint; // = "4DEDD3345AAC78DE99F5136DFBFE7C49";
  static const uint8_t binary_fingerprint[16]; // = {0x4D,0xED,0xD3,0x34,0x5A,0xAC,0x78,0xDE,0x99,0xF5,0x13,0x6D,0xFB,0xFE,0x7C,0x49};

  MT4ChartInfo(const MT4ChartInfo&);
  MT4ChartInfo& operator=(const MT4ChartInfo&);
  MT4ChartInfo() : symbol(), period((MT4PERIOD_TYPE::type)0), start(0), _end(0), timesign(0), mode((MT4CHART_TYPE::type)0) {
  }

  virtual ~MT4ChartInfo() throw();
  std::string symbol;
  MT4PERIOD_TYPE::type period;
  int64_t start;
  int64_t _end;
  int64_t timesign;
  MT4CHART_TYPE::type mode;

  _MT4ChartInfo__isset __isset;

  void __set_symbol(const std::string& val);

  void __set_period(const MT4PERIOD_TYPE::type val);

  void __set_start(const int64_t val);

  void __set__end(const int64_t val);

  void __set_timesign(const int64_t val);

  void __set_mode(const MT4CHART_TYPE::type val);

  bool operator == (const MT4ChartInfo & rhs) const
  {
    if (!(symbol == rhs.symbol))
      return false;
    if (!(period == rhs.period))
      return false;
    if (!(start == rhs.start))
      return false;
    if (!(_end == rhs._end))
      return false;
    if (!(timesign == rhs.timesign))
      return false;
    if (!(mode == rhs.mode))
      return false;
    return true;
  }
  bool operator != (const MT4ChartInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MT4ChartInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const MT4ChartInfo& obj);
};

void swap(MT4ChartInfo &a, MT4ChartInfo &b);

typedef struct _MT4RateInfo__isset {
  _MT4RateInfo__isset() : ctm(false), open(false), high(false), low(false), close(false), vol(false) {}
  bool ctm :1;
  bool open :1;
  bool high :1;
  bool low :1;
  bool close :1;
  bool vol :1;
} _MT4RateInfo__isset;

class MT4RateInfo {
 public:

  static const char* ascii_fingerprint; // = "BD11AF0EAECF781E472445A783BFCB36";
  static const uint8_t binary_fingerprint[16]; // = {0xBD,0x11,0xAF,0x0E,0xAE,0xCF,0x78,0x1E,0x47,0x24,0x45,0xA7,0x83,0xBF,0xCB,0x36};

  MT4RateInfo(const MT4RateInfo&);
  MT4RateInfo& operator=(const MT4RateInfo&);
  MT4RateInfo() : ctm(0), open(0), high(0), low(0), close(0), vol(0) {
  }

  virtual ~MT4RateInfo() throw();
  int64_t ctm;
  int32_t open;
  int32_t high;
  int32_t low;
  int32_t close;
  double vol;

  _MT4RateInfo__isset __isset;

  void __set_ctm(const int64_t val);

  void __set_open(const int32_t val);

  void __set_high(const int32_t val);

  void __set_low(const int32_t val);

  void __set_close(const int32_t val);

  void __set_vol(const double val);

  bool operator == (const MT4RateInfo & rhs) const
  {
    if (!(ctm == rhs.ctm))
      return false;
    if (!(open == rhs.open))
      return false;
    if (!(high == rhs.high))
      return false;
    if (!(low == rhs.low))
      return false;
    if (!(close == rhs.close))
      return false;
    if (!(vol == rhs.vol))
      return false;
    return true;
  }
  bool operator != (const MT4RateInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MT4RateInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  friend std::ostream& operator<<(std::ostream& out, const MT4RateInfo& obj);
};

void swap(MT4RateInfo &a, MT4RateInfo &b);



#endif
